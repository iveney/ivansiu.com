<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Zigang Xiao]]></title>
  <link href="http://blog.ivansiu.com/atom.xml" rel="self"/>
  <link href="http://blog.ivansiu.com/"/>
  <updated>2013-10-17T14:58:24-05:00</updated>
  <id>http://blog.ivansiu.com/</id>
  <author>
    <name><![CDATA[Zigang Xiao (Ivan)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Updating Octopress Theme]]></title>
    <link href="http://blog.ivansiu.com/blog/2013/10/17/updating-octopress-theme/"/>
    <updated>2013-10-17T14:54:00-05:00</updated>
    <id>http://blog.ivansiu.com/blog/2013/10/17/updating-octopress-theme</id>
    <content type="html"><![CDATA[<p>The themes are stored in <code>.themes/&lt;name&gt;</code>, we can use the rake command to update either the source or style, as documented in the <a href="http://octopress.org/docs/updating/">office website</a>. However, the syntax should be more clear, i.e.,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake update_source['theme name']</span></code></pre></td></tr></table></div></figure>


<p>Without the brackets, it defaults to <code>.themes/classic</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Graph Matching: Hopcroft-Karp Algorithm]]></title>
    <link href="http://blog.ivansiu.com/blog/2013/10/08/graph-matching-hopcroft-karp-algorithm/"/>
    <updated>2013-10-08T15:59:00-05:00</updated>
    <id>http://blog.ivansiu.com/blog/2013/10/08/graph-matching-hopcroft-karp-algorithm</id>
    <content type="html"><![CDATA[<h2>Overview</h2>

<p>Hopcroft-Karp algorithm also utilizes the augmenting path. The difference
between the <a href="http://blog.ivansiu.com/blog/2013/10/07/graph-matching-augmenting-path/">simple augmenting path algorithm</a> is, instead of searching
augmenting path one by one, it looks for many paths in the same time. The paths found at each iteration are in fact <strong>vertex disjoint path</strong>.
By doing so, the number of iterations can be cut down, since there cannot be too many disjoing paths.</p>

<p>The major observation is that the length of augementing path grows at each step. Thus, if we keep finding a set of vertex disjoint augmenting paths,
the algorithm is guaranteed to stop eventually and faster than finding the path one by one.</p>

<!-- more -->


<h2>Finding Maximal Set of Vertex Disjoint Paths</h2>

<p>Let $G=(U \cup V, E)$ be the bipartite graph and $G_M$ be the directed graph w.r.t to matching $M$.
The <strong>layered graph</strong> is contructed out of $G_M$, where the distance at a vertex $v$ is defined as the length of shortest path from some vertices in $U$.</p>

<p>This can done by simply running a modified BFS on $G_M$: we start by enqueing all the free vertices $U&#8217;$ in $U$ and label them as 0 (distance),
propagate and label until one or more free vertices in $V$ are reached. Let the label (distance) be $k$, and denote this graph as $L$.</p>

<p>We can then run a modified DFS on $L$, starting from any of the vertices in $U&#8217;$. Whenever we reach a free vertices in $V$, we delete the path $p$
from $L$, and repeat. It can be proven that all the paths found are shortest vertex disjoint paths of length $k$. This set of paths are the maximal set
we are looking for.</p>

<h2>Algorithm Outline</h2>

<ul>
<li>MAXIMAL-SET-OF-PATHS($G=(U \cup V, E), M$)

<ul>
<li>$P \gets \varnothing$</li>
<li>$L \gets $ Run modified BFS on $G_M$</li>
<li>$U&#8217; \gets $ free vertices in $U$</li>
<li>for $u \in U&#8217;$

<ul>
<li>$p \gets $ PARTIAL-DFS($G, v, T$)</li>
<li>if $p \neq \varnothing $

<ul>
<li>$P = P \cup p$</li>
<li>Remove $p$ from $L$</li>
</ul>
</li>
</ul>
</li>
<li>return $P$</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>HOPCROFT-KARP($G$)

<ul>
<li>$M \gets \varnothing$</li>
<li>repeat

<ul>
<li>$P \gets $ MAXIMAL-SET-OF-PATHS($G, M$)</li>
<li>if $P \neq \varnothing$

<ul>
<li>$M \gets M \oplus P$</li>
</ul>
</li>
</ul>
</li>
<li>until $P = \varnothing$</li>
<li>return $M$</li>
</ul>
</li>
</ul>


<h2>Analysis</h2>

<p>It can be shown that the loop will be executed at most $O(\sqrt{|V|})$ times, and running the DFS and BFS requires $O(|E|)$ time.
Thus the overall run time is $O(\sqrt{|V|} |E|)$.</p>

<h2>Reference</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Hopcroft-Karp">Wikipedia article</a></li>
<li><a href="http://www.dis.uniroma1.it/~sankowski/lecture2.pdf">Lecture note from Sapienza University of Rome</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Graph Matching: Augmenting Path]]></title>
    <link href="http://blog.ivansiu.com/blog/2013/10/07/graph-matching-augmenting-path/"/>
    <updated>2013-10-07T18:47:00-05:00</updated>
    <id>http://blog.ivansiu.com/blog/2013/10/07/graph-matching-augmenting-path</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Let $G=(V, E)$ be an undirected graph. Matching in $G$ is a subset of edges $M \subseteq E$ such that at most one edge is incident to each vertex in $V$.</p>

<p>A vertex is <em>matched</em> is it is incident to some edge in $M$, otherwise it is called <em>free</em> or <em>exposed</em>.</p>

<h2>Augmenting Paths</h2>

<ul>
<li>Alternating path: a path in which the edges belong alternatively to the matching and not to the matching</li>
<li>Augmenting path: an alternating path that starts from and ends on exposed vertices</li>
</ul>


<p>Clearly, an augmenting path can be &lsquo;flipped&rsquo; to increase the matching size <strong>by one</strong>, i.e., just make free vertex matched and make matched vertex free in this path.</p>

<p><strong>Berge&rsquo;s Theorem</strong>:  The matching M is maximum <strong>iff</strong> there is no augmenting path w.r.t. $M$. I personally think the proof is easy but quite powerful.</p>

<p>Thus, we can immediately use the theorem to design an algorithm: find augmenting path iteratively until no more can be found. The problem is how we can find the augmenting path.</p>

<!-- more -->


<h2>Algorithm for bipartite graph</h2>

<p>FIND-AUGMENTING-PATH($G=(V_1 \cup V_2, E), M$)</p>

<ul>
<li>$V&#8217;_1$ = a set of free vertices in $V_1$</li>
<li>$V&#8217;_2$ = a set of free vertices in $V_2$</li>
<li>Construct the directed graph $G_M = (V_1 \cup V_2, E_M)$

<ul>
<li>$E_M$ is a set of directed edges such that it includes all arcs from $V_1$ to $V_2$, and all matching arcs from $V_2$ to $V_1$</li>
<li>i.e., $E_M = \{(v_1, v_2) : v_1, v_2 \in E \setminus M, v_1 \in V_1, v_2 \in V_2\} \cup \{(v_2, v_1) : v_1, v_2 \in M, v_1 \in V_1, v_2 \in V_2\}$</li>
</ul>
</li>
<li>Find a simple path $p$ from $V&#8217;_1$ to $V&#8217;_2$ in $G_M$</li>
</ul>


<p>Note that the above graph $G_M$ is similar to the residual network in network flow. Apparently, $p$ starts from a free vertex in $V&#8217;_1$ and ends at another free vertex in $V&#8217;_2$, thus it is an augmenting path.</p>

<h2>Complexity</h2>

<p>The maximum size of matching is upper bounded by $|V|/2$, and each step, the matching size is incremented by one. Thus, the number of augmenting path found will be at most $O(|V|)$. At each step, it takes $O(|E|)$ to find a path. Thus the overall running time is $O(|V||E|)$.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Flow: Push-relabel algorithm]]></title>
    <link href="http://blog.ivansiu.com/blog/2013/10/07/network-flow-push-relabel-algorithm/"/>
    <updated>2013-10-07T18:08:00-05:00</updated>
    <id>http://blog.ivansiu.com/blog/2013/10/07/network-flow-push-relabel-algorithm</id>
    <content type="html"><![CDATA[<p>According to CLRS: Many of the asymptotically fastest maximum-flow algorithms are push-relabel algorithms, and the fastest actual implementations of maximum-flow algorithms are based on the push-relabel method. Push-relabel methods also efficiently solve other flow problems, such as the minimum-cost flow problem.</p>

<p>This algorithm has a very different flavor. The overall idea is to generate a &lsquo;preflow&rsquo; that may not satisfy the flow properties, and keep &lsquo;pushing&rsquo;) and &lsquo;elevating&rsquo; (relabelling) the vertices until we cannot do that. We then remove the &lsquo;excess&rsquo; from the preflow and obtain a valid flow, which is also a max flow. In particular, the in-flow may be larger than out-flow at a vertex. The amount of overflow is called &lsquo;excess&rsquo;.</p>

<!-- more -->


<p>The intuition behind is this: think of the vertices as platforms that have different height, where initially $S$ has $|V|$ height and all other vertices have 0 heights. The flow can only be pushed from higher vertices to lower vertices. Whenever we do not have any flow to push, we find some vertex  that has unsaturated out edge to its neighbor vertices to &lsquo;relabel&rsquo;, i.e., elevating its height such that we can continue to &lsquo;push&rsquo;. Thus, there are two operations &lsquo;push&rsquo; and &lsquo;relabel&rsquo; (and thus the name):</p>

<pre><code>push: sending excess from u to v
relabel: increase the height of u to min({v: neighbor of u})+1
</code></pre>

<p>The algorithm is as follows:</p>

<pre><code>Initialize s.h = |V|, u.h = 0 for u != s. // u.h is the height of vertex u
For all (s, u), push c(s, u). // saturate all outgoing edges from s.
While there is vertex that can be pushed or relabel
  do push or relabel
End while
return F.
</code></pre>

<p>The naive implementation has runtime $O(|V|^2 |E|)$, and can be improved to $O(|V|^3)$.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Flow: Ford-Fulkerson Method]]></title>
    <link href="http://blog.ivansiu.com/blog/2013/10/03/network-flow-ford-fulkerson-method/"/>
    <updated>2013-10-03T18:13:00-05:00</updated>
    <id>http://blog.ivansiu.com/blog/2013/10/03/network-flow-ford-fulkerson-method</id>
    <content type="html"><![CDATA[<p>Basic method (framework) is Ford-Fulkerson. It&rsquo;s called a &ldquo;method&rdquo; because it&rsquo;s
general, there can be different implementation that yield different complexity.
It looks like this:</p>

<pre><code>Let F be an empty flow
While there is augmenting path P from s to t
    Augment F with P
End while
</code></pre>

<p>The problem is how we find the augmenting path efficiently. A naive
implementation is to use DFS to randomly pick a $s-t$ path and augment it.
However, it has two problems:</p>

<!-- more -->


<ol>
<li>The algorithm may not terminate, this happens when the capacity is
irrational number (we can always scale rational to integer). When the
capacity is irrational, the flow may fluctuate and never converge.</li>
<li>Even when the capacity is integer, the algorithm may be too slow. The
runtime depends on the size of flow $|F|$, which means if $|F|$ is large, it
takes a long time to stop. To see this, note that DFS takes $|E|$ time, in the
worst case, $F$ may grow by 1 at each iteration (since capacity is integer).
Thus, the complexity is $O(|E||F|)$.</li>
</ol>


<p>To handle, this, Edmonds-Karp algorithm simply replaces the DFS as BFS, which
finds a shortest each time (use unit length on edges in the residual graph).
The major points are:</p>

<ul>
<li>The length shortest path is guaranteed to monotonically increase at each
iteration. This can be proven by contradiction.</li>
<li>The number of iterations are $O(|V||E|)$.

<ul>
<li>Each augmenting path (shortest path) can saturate one edge, and this edge
will disappear from the residual graph. We call this edge &lsquo;critical&rsquo;.</li>
<li>An edge $(u, v)$ becomes critical to the time when it next becomes
critical, the distance to $u$ from the source increases by at least 2.</li>
<li>Thus, the total number of critical edges during execution is $O(|V||E|)$.</li>
<li>Each augmenting path contains at least one critical edge, thus $O(|V||E|)$.</li>
</ul>
</li>
<li>The running time is thus $O(|V||E|^2)$ since each iteration we run a BFS
which costs $O(|E|)$. This can be improved to $O(|V|^2|E|)$ with more
efficient data structure (Dinic).</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Installing a new car stereo]]></title>
    <link href="http://blog.ivansiu.com/blog/2013/08/30/installing-a-new-car-stereo/"/>
    <updated>2013-08-30T16:50:00-05:00</updated>
    <id>http://blog.ivansiu.com/blog/2013/08/30/installing-a-new-car-stereo</id>
    <content type="html"><![CDATA[<p>I did not realize until my car&rsquo;s radio&rsquo;s broken that, with less than a hundred bucks, you can buy a new Head Unit with nearly all functionality. Some note-worthy features include:</p>

<ul>
<li>iPod/iPhone support. Control the iphone directly from the panel.</li>
<li>App support. This includes I-heart-radio, pandora, etc.</li>
<li>Bluetooth Audio: stream music directly from a paired device. Even supports Pandora!</li>
<li>Upgraded FM/AM support. Displays text from radio stations.</li>
</ul>


<p> <!-- more --></p>

<p>Since I never used CD, I actually decided to buy a Digital Media Receiver: <a href="http://www.crutchfield.com/S-kT2jsjodqXG/p_105KDX250B/JVC-KD-X250BT.html">JVC KD-X250BT</a>. Since every car has a different wiring harness, we need to buy a compatible wiring harness. My car has a Double DIN design but the DMR is a single DIN one, so I actually need to buy a installation kit. The wiring setup is fun:</p>

<p><img class="left" src="https://lh5.googleusercontent.com/-zOOgWaP5-W8/UiETJQhmUVI/AAAAAAAA6AM/jRAo6LHRlDU/s400/IMG_5341.jpg">
<img class="right" src="https://lh4.googleusercontent.com/-n_QzAv5VgfQ/UiETKOBShuI/AAAAAAAA6AU/_F3-gN-NDio/s400/IMG_5342.jpg">
<img class="left" src="https://lh5.googleusercontent.com/-p7tlzn7kbRc/UiETKzbUaCI/AAAAAAAA6Ac/37Dgx3cbUJM/s400/IMG_5344.jpg"></p>

<p><img class="right" src="https://lh6.googleusercontent.com/-KJRCnhX64lg/UiETLxnhJKI/AAAAAAAA6Ak/qdqbEPUfAUI/s600/IMG_5345.JPG">
<img src="https://lh5.googleusercontent.com/-h0tu6PrFzIk/UiETMWNKURI/AAAAAAAA6As/Zll5LFDkixM/s600/IMG_5346.JPG"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Roadtrip in America 2013]]></title>
    <link href="http://blog.ivansiu.com/blog/2013/08/28/roadtrips-in-us-2013/"/>
    <updated>2013-08-28T16:17:00-05:00</updated>
    <id>http://blog.ivansiu.com/blog/2013/08/28/roadtrips-in-us-2013</id>
    <content type="html"><![CDATA[<p>In this year, I did several crazy road trips, each trip has about 3k miles. Here&rsquo;re them.</p>

<h1>Winter Trip</h1>

<p>The first trip is a trip with my parents, where they flied to Chicago and I drove them to UIUC for a visit.
We then flied to LA and rented a car to start our road trip. The whole trip was mainly in California, though
we drove a bit east and visited Las Vegas and Grand canyon.</p>

<p><img src="https://lh3.googleusercontent.com/-3XKmLgVuYw8/UlBRR-rXocI/AAAAAAAA6Qg/IIHynx2WdOQ/s800/Winter%2520trip.png"></p>

<!-- more -->


<h1>Route 66</h1>

<p>I drove from Champaign all the way to Mountain View, with most of the part of <a href="https://en.wikipedia.org/wiki/U.S._Route_66">Route 66</a>.</p>

<p><img src="https://lh5.googleusercontent.com/-fMUI4Zi2a68/UlBUCwGlIoI/AAAAAAAA6Q0/14KGATd9IHw/s800/Champaign%252C%2520IL%2520to%2520Mountain%2520View%252C%2520CA%2520-%2520Google%2520Maps.png"></p>

<h1>I-80</h1>

<p>After my internship in California, I drove back from Mountain View to Champaign.</p>

<p><img src="https://lh6.googleusercontent.com/-QEnrQ49XzlQ/UlBQLfKAtTI/AAAAAAAA6QM/JBcEAGUNxiI/s800/Sunnyvale%252C%2520CA%2520to%2520Champaign%252C%2520IL%2520-%2520Google%2520Maps.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on SSH port forwarding]]></title>
    <link href="http://blog.ivansiu.com/blog/2013/05/09/notes-on-ssh-port-forwarding/"/>
    <updated>2013-05-09T21:43:00-05:00</updated>
    <id>http://blog.ivansiu.com/blog/2013/05/09/notes-on-ssh-port-forwarding</id>
    <content type="html"><![CDATA[<h3>SSH Local Port Forwarding</h3>

<p>Use <code>ssh -L</code> to bind a local port to a remote port</p>

<h3>Dynamic Port Forwarding</h3>

<p>Use <code>ssh -D</code> to dynamically bind a local port for forwarding. A SOCKS5 will be created. Example:</p>

<pre><code>ssh -D 1080 user@remote-server.com
</code></pre>

<p>This binds to remote-server.com and uses local port 1080 for forwarding.</p>

<p>Optionally use -C for data compression.</p>

<p>The above command will log into the remote-server.com, use <code>-f</code> to put ssh to background, and use <code>-N</code> to not to execute a command. i.e.,</p>

<pre><code>ssh -f -N -D 1080 user@remote-server.com
</code></pre>

<!-- more -->


<h3>Usage Example</h3>

<p>If the tool/app supports socks natively, use localhost:1080 in its setting. Example (curl)</p>

<pre><code>curl --socks5 localhost http://icanhazip.com
</code></pre>

<p>If set up correctly, the IP returned will be the machine that is forwarding (remote-server.com)</p>

<p>If not, use some socksify tool, for example, use dsocks in OSX:</p>

<pre><code>dsocks.sh ssh another-server.com
</code></pre>

<p>You can see where you logon using <code>who | grep &lt;user-name&gt;</code>.</p>

<h3>A Real World Scenario</h3>

<p>Scenario: I want to connect to VNC server at peabody::5903, however, peabody only accepts connection from CSL LAN, while my Macbook is in IllinoisNet (wireless).</p>

<p>Solution: use my office computer &lsquo;orange&rsquo; as a proxy. Use local port forwarding:</p>

<pre><code>ssh -L 5903:peabody:5903 orange
</code></pre>

<p>This means, forward localhost:5903 via orange to peabody:5903
So if I connect to the vnvserver at:</p>

<pre><code>localhost :1 # port is 5901
</code></pre>

<p>I am forwarded to</p>

<pre><code>peabody :3 # port is 5903
</code></pre>

<h3>More On Port Forwarding</h3>

<p><a href="https://help.ubuntu.com/community/SSH/OpenSSH/PortForwarding">https://help.ubuntu.com/community/SSH/OpenSSH/PortForwarding</a></p>
]]></content>
  </entry>
  
</feed>
